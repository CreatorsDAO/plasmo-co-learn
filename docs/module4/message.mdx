---
sidebar_position: 5
---

# Message API

`Plasmo` 提供了封装好的 Message API , 这让扩展各个模块之间通信变得简单。
在你的 `Plasmo`项目目录中的 `background` 目录，添加 `Message` 文件目录， `Plasmo` 将为你完成剩余的工作。
`Plasmo` 提供声明式的、类型安全的 函数结构，同时提供 `Promise`结构的异步函数执行结构。

## 安装模块

```shell
pnpm install @plasmohq/messaging
```

安装完成后，在你的 `Plasmo` 的 `background` 目录 创建 messages 模块。
如果你使用了 `background.ts`, 那么你需要创建 `background` 目录， 其中创建 `index.ts`。

## 模块及通信规则

| Messaging API                 | From         | To           | One-time | Long-lived |
| :---------------------------- | :----------- | :----------- | :------- | :--------- |
| [Message Flow](#message-flow) | Ext-Pages/CS | BGSW         | Yes      | No         |
| [Relay Flow](#relay-flow)     | Website      | CS/BGSW      | Yes      | No         |
| [Ports](#ports)               | Ext-Pages/CS | BGSW         | No       | Yes        |
| Ports                         | BGSW         | Ext-Pages/CS | No       | Yes        |
| Ports + Relay                 | BGSW         | WebPage      | Yes      | Yes        |

## 官方示例

- 官方示例 : [with-messaging](https://github.com/PlasmoHQ/examples/tree/main/with-messaging)

## Message Flow

使用 `Message Flow` 可以完成扩展组件间的一次性通信。
通信双方可以是 `tab page`、`content script` 、 `background service worker`。
这种通信规则，可以把大量的数据计算或者因为 CORS 规则无法调用的函数放到`background`中去完成。

`background service` 的工作函数是一个信息中心，每个服务都包含一个 Rest API 样式的处理器。
你可以很方便的在 `background/messages` 创建一个 ts 模块，文件名将会是 message 的名字，默认导出的函数必须是函数处理器。

```ts title="background/messages/ping.ts"
import type { PlasmoMessaging } from "@plasmohq/messaging";

const handler: PlasmoMessaging.MessageHandler = async (req, res) => {
  const message = await querySomeApi(req.body.id);

  res.send({
    message,
  });
};

export default handler;
```

:::info
https://docs.plasmo.com/framework/messaging
:::
