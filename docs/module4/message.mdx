---
sidebar_position: 5
---

# Message API

`Plasmo` 提供了封装好的 Message API , 这让扩展各个模块之间通信变得简单。
在你的 `Plasmo`项目目录中的 `background` 目录，添加 `Message` 文件目录， `Plasmo` 将为你完成剩余的工作。
`Plasmo` 提供声明式的、类型安全的 函数结构，同时提供 `Promise`结构的异步函数执行结构。

## 安装模块

```shell
pnpm install @plasmohq/messaging
```

安装完成后，在你的 `Plasmo` 的 `background` 目录 创建 messages 模块。
如果你使用了 `background.ts`, 那么你需要创建 `background` 目录， 其中创建 `index.ts`。

## 模块及通信规则

| Messaging API                 | From         | To           | One-time | Long-lived |
| :---------------------------- | :----------- | :----------- | :------- | :--------- |
| [Message Flow](#message-flow) | Ext-Pages/CS | BGSW         | Yes      | No         |
| [Relay Flow](#relay-flow)     | Website      | CS/BGSW      | Yes      | No         |
| [Ports](#ports)               | Ext-Pages/CS | BGSW         | No       | Yes        |
| Ports                         | BGSW         | Ext-Pages/CS | No       | Yes        |
| Ports + Relay                 | BGSW         | WebPage      | Yes      | Yes        |

## 官方示例

- 官方示例 : [with-messaging](https://github.com/PlasmoHQ/examples/tree/main/with-messaging)

## Message Flow

使用 `Message Flow` 可以完成扩展组件间的一次性通信。 这是一种和普通的 API 接口非常相似的一种交互方式。

通信双方可以是 `tab page`、`content script`相当于我们的前端页面， `background service worker` 相当于我们的后端 API 接口。
这种通信规则，可以把大量的数据计算或者因为 CORS 规则无法调用的函数放到`background`中去完成。

`background service` 的工作函数是一个信息中心，每个服务都包含一个 Rest API 样式的处理器。
你可以很方便的在 `background/messages` 创建一个 ts 模块，文件名将会是 message 的名字，默认导出的函数必须是函数处理器。

```ts title="background/messages/ping.ts"
import type { PlasmoMessaging } from "@plasmohq/messaging";

const handler: PlasmoMessaging.MessageHandler = async (req, res) => {
  const message = await querySomeApi(req.body.id);

  res.send({
    message,
  });
};

export default handler;
```

以上是类似的后端 API 接口，接下来我们介绍 如何调用。
在 扩展页面、Content Script 或者 tab page 中我们通过 `@plasmohq/messaging` 的 API 发起交互。

由于 `Plasmo` 在后台可以解析我们的 Service 调用，你使用的 IDE 触发消息名称的提示感知。

```ts title="popup.tsx"
import { sendToBackground } from "@plasmohq/messaging"

...
const resp = await sendToBackground({
  name: "ping",
  body: {
    id: 123
  }
})

console.log(resp)
```

如果你需要从前端的 `content script` 向后端发起交互，那么你需要你的 扩展 ID。
你看的扩展 ID 可以通过， `chrome://extensions` 扩展管理页面获得。

```ts title="contents/componentInTheMainWorld.tsx"
import { sendToBackground } from "@plasmohq/messaging"
import type { PlasmoCSConfig } from "plasmo"

export const config: PlasmoCSConfig = {
  matches: ["<all_urls>"],
  world: "MAIN"
}
...
const resp = await sendToBackground({
  name: "ping",
  body: {
    id: 123
  },
  extensionId: 'llljfehhnoeipgngggpomjapaakbkyyy' // find this in chrome's extension manager
})

console.log(resp)
```

:::tip
这样，自然也带来了一个问题。扩展 ID 怎么获得呢？

1. 开发阶段你可以通过，扩展管理器中获得，开发过程中保持不变。
2. 发布后怎么获得呢？
   一种解决思路是，通过 `background` 中调用 `chrome.runtime.id` 获得。然后通过其他途径传递到前端`Content-Script`

:::

:::info
https://docs.plasmo.com/framework/messaging
:::
